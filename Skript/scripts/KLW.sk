import:
	java.util.ArrayList
	java.util.HashMap
	net.minecraft.server.v1_11_R1.BossBattle
	net.minecraft.server.v1_11_R1.BossBattle$BarColor
	net.minecraft.server.v1_11_R1.BossBattle$BarStyle
	net.minecraft.server.v1_11_R1.BossBattleServer
	net.minecraft.server.v1_11_R1.PacketPlayOutBoss$Action
	net.minecraft.server.v1_11_R1.PathfinderGoalFloat
	net.minecraft.server.v1_11_R1.PathfinderGoalSelector
	org.bukkit.craftbukkit.v1_11_R1.util.CraftChatMessage
	org.bukkit.entity.EntityType


function spawnKLW(ply: player):
	{BOSS}.containsKey("骷髅王") is false
	set {_loc} to location of {NPC}.get("裁缝")
	spawn a slime at {_loc}
	set {_klw} to spawned entity
	spawn a slime at {_loc}
	set {_hand1} to spawned entity
	spawn a slime at {_loc}
	set {_hand2} to spawned entity
	handleKLW({_klw}, {_ply}, {_hand1}, {_hand2})

function handleKLW(klw: entity, ply: player, hand1: entity, hand2: entity):
	broadcast "&d&l骷髅王 苏醒了！"
	play sound "entity.enderdragon.growl" with volume 10 and pitch 1 at location of {_klw}
	set {_attrMapSkull} to new HashMap(10)
	{_attrMapSkull}.put("crit", 0.04)
	{_attrMapSkull}.put("damage", 85)
	{_attrMapSkull}.put("damageBulletMulti", 1)
	{_attrMapSkull}.put("damageRangedMulti", 1)
	{_attrMapSkull}.put("damageMulti", 1)
	{_attrMapSkull}.put("damageType", "Bullet")
	{_attrMapSkull}.put("knockback", 2)
	{_attrMapSkull}.put("knockbackBulletMulti", 1)
	{_attrMapSkull}.put("knockbackRangedMulti", 1)
	{_attrMapSkull}.put("knockbackMulti", 1)
	set {_attrMap} to new HashMap(11)
	{_attrMap}.put("crit", 0.04)
	{_attrMap}.put("damage", 85)
	{_attrMap}.put("damageMeleeMulti", 1)
	{_attrMap}.put("damageMulti", 1)
	{_attrMap}.put("damageType", "Melee")
	{_attrMap}.put("defence", 70)
	{_attrMap}.put("defenceMulti", 1)
	{_attrMap}.put("knockback", 1)
	{_attrMap}.put("knockbackResistance", 1)
	{_attrMap}.put("knockbackMeleeMulti", 1)
	{_attrMap}.put("knockbackMulti", 1)
	set {_attrMapHand} to {_attrMap}.clone()
	{_attrMapHand}.put("defence", 14)
	{_attrMapHand}.put("damage", 66)
	set metadata "attrMap" of {_klw} to {_attrMap}
	set metadata "attrMap" of {_hand1} to {_attrMapHand}
	set metadata "attrMap" of {_hand2} to {_attrMapHand}
	
	set {_bossbar} to new BossBattleServer(CraftChatMessage.fromString("骷髅王", true)[0], BarColor.GREEN, BarStyle.PROGRESS)
	{_bossbar}.setVisible(true)
	set metadata "bossbar" of {_klw} to {_bossbar}
	
	set {_targets} to new HashMap()
	loop all players in {_klw}.getWorld():
		{_bossbar}.addPlayer(loop-player.getHandle())
		{_targets}.put(name of loop-player, 0)
	set metadata "targets" of {_klw} to {_targets}
	set metadata "targets" of {_hand1} to {_targets}
	set metadata "targets" of {_hand2} to {_targets}
	set {_healthMulti} to getBossHealthMulti({_targets}.size())
	set name of {_klw} to "骷髅王"
	{_klw}.setCustomName("骷髅王")
	add "isMonster" to scoreboard tags of {_klw}
	add "isBOSS" to scoreboard tags of {_klw}
	{_klw}.setCustomNameVisible(true)
	set name of {_hand1} to "骷髅王左手"
	add "isMonster" to scoreboard tags of {_hand1}
	add "isBOSS" to scoreboard tags of {_hand1}
	{_hand1}.setCustomName("骷髅王左手")
	{_hand1}.setCustomNameVisible(true)
	set name of {_hand2} to "骷髅王右手"
	add "isMonster" to scoreboard tags of {_hand2}
	add "isBOSS" to scoreboard tags of {_hand2}
	{_hand2}.setCustomName("骷髅王右手")
	{_hand2}.setCustomNameVisible(true)
	
	{_klw}.setRemoveWhenFarAway(false)
	{_klw}.setGravity(false)
	slimeResize({_klw}, 8)
	{_hand1}.setRemoveWhenFarAway(false)
	{_hand1}.setGravity(false)
	slimeResize({_hand1}, 5)
	{_hand2}.setRemoveWhenFarAway(false)
	{_hand2}.setGravity(false)
	slimeResize({_hand2}, 5)
	
	set {_bossArlst} to new ArrayList(3)
	{_bossArlst}.add({_klw})
	{_bossArlst}.add({_hand1})
	{_bossArlst}.add({_hand2})
	{BOSS}.put("骷髅王", {_bossArlst})
	
	set max health of {_klw} to round(8800 * {_healthMulti})
	set health of {_klw} to round(8800 * {_healthMulti})
	set max health of {_hand1} to round(1560 * {_healthMulti})
	set health of {_hand1} to round(1560 * {_healthMulti})
	set max health of {_hand2} to round(1560 * {_healthMulti})
	set health of {_hand2} to round(1560 * {_healthMulti})
	set {_countAI} to 0
	set {_target} to {_ply}
	set {_hand1AI} to true
	set {_hand2AI} to true
	set {_angry} to false
	
	makeTarget({_klw}, {_target})
	renderSingleBossbar({_klw}, {_bossbar})
	wait 1 tick
	
	while health of {_klw} > 0:
		if {_klw}.getWorld().getTime() is between 22490 and 22510:
			set {_angry} to true
			{_attrMap}.put("damageType", "boss_angry")
			set {_bossbar}.color to BarColor.RED
			{_bossbar}.sendUpdate(Action.UPDATE_STYLE)
			{_attrMap}.put("defence", 10000)
			{_hand1}.remove()
			{_hand2}.remove()
		#clear invalid targets
		if {_target} is set:
			checkBossTarget({_target}, {_klw}, false) is false
			clear {_target}
		
		if {_target} is not set:
			loop toSkList {_targets}.keySet():
				set {_ply} to "%loop-value%" parsed as player
				checkBossTarget({_ply}, {_klw}, false) is true
				set {_target} to {_ply}
				makeTarget({_klw}, {_target})
				stop loop
			#find new target if avaliable, otherwise flee
		if {_target} is not set:
			#flee
			teleport {_klw} to (location of {_klw}).subtract(0, 5, 0)
			teleport {_hand1} to (location of {_hand1}).subtract(0, 5, 0)
			teleport {_hand2} to (location of {_hand2}).subtract(0, 5, 0)
			if y-coordinate of location of {_klw} <= 30:
				set max health of {_klw} to 1
				{_klw}.remove()
				{_hand1}.remove()
				{_hand2}.remove()
				stop loop
		else:
			#AI part starting here
			set {_countAI} to mod({_countAI}, 170)
			#hand AI
			if health of {_hand1} + health of {_hand2} > 0:
				set {_distanceVec} to {_klw}.getLocation().subtract({_target}.getLocation()).toVector().normalize()
				if {_hand1AI}:
					if health of {_hand1} > 0:
						if {_countAI} = 0:
							set {_dVec1} to vector({_distanceVec}.getZ() * -10, 10, {_distanceVec}.getX() * 10)
						else if {_countAI} = 10:
							clear {_dVec1}
							set {_destination1} to {_target}.getLocation().add(({_distanceVec}.getZ() * -22), 0, ({_distanceVec}.getX() * 22))
						else if {_countAI} = 20:
							set {_destination1} to {_target}.getLocation()
						else if {_countAI} = 50:
							clear {_dVec1}
							set {_destination1} to {_target}.getLocation().add(({_distanceVec}.getZ() * -5), 22, ({_distanceVec}.getX() * 5))
						else if {_countAI} = 60:
							set {_destination1} to {_target}.getLocation()
						else if {_countAI} is 30 or 70:
							set {_dVec1} to vector({_distanceVec}.getZ() * -10, 10, {_distanceVec}.getX() * 10)
						if {_dVec1} is set:
							set {_dVec1} to vector({_distanceVec}.getZ() * -10, 10, {_distanceVec}.getX() * 10)
							set {_destination1} to {_klw}.getLocation().add({_dVec1})
							set {_vHand1} to {_destination1}.clone().subtract({_hand1}.getLocation()).toVector()
							set vector length of {_vHand1} to min(3, (distance between {_destination1} and location of {_hand1}) / 10)
						else if {_destination1} is set:
							set {_vHand1} to {_destination1}.clone().subtract({_hand1}.getLocation()).toVector()
							if {_countAI} is 10 or 50:
								set vector length of {_vHand1} to (distance between {_destination1} and location of {_hand1}) / 10
							else:
								set vector length of {_vHand1} to max(3, (distance between {_destination1} and location of {_hand1}) / 6)
							clear {_destination1}
						set {_locHand} to location of {_hand1}
						teleport {_hand1} to {_locHand}.add({_vHand1})
					else:
						set {_hand1AI} to false
						{_attrMap}.put("defence", ({_attrMap}.get("defence") - 30))
				if {_hand2AI}:
					if health of {_hand2} > 0:
						if {_countAI} = 0:
							set {_dVec2} to vector({_distanceVec}.getZ() * 10, 10, {_distanceVec}.getX() * -10)
						else if {_countAI} = 30:
							clear {_dVec2}
							set {_destination2} to {_target}.getLocation().add(({_distanceVec}.getZ() * 22), 0, ({_distanceVec}.getX() * -22))
						else if {_countAI} = 40:
							set {_destination2} to {_target}.getLocation()
						else if {_countAI} = 70:
							clear {_dVec2}
							set {_destination2} to {_target}.getLocation().add(({_distanceVec}.getZ() * 5), 22, ({_distanceVec}.getX() * -5))
						else if {_countAI} = 80:
							set {_destination2} to {_target}.getLocation()
						else if {_countAI} = 50 or 90:
							set {_dVec2} to vector({_distanceVec}.getZ() * 10, 10, {_distanceVec}.getX() * -10)
						if {_dVec2} is set:
							set {_dVec2} to vector({_distanceVec}.getZ() * 10, 10, {_distanceVec}.getX() * -10)
							set {_destination2} to {_klw}.getLocation().add({_dVec2})
							set {_vHand2} to {_destination2}.clone().subtract({_hand2}.getLocation()).toVector()
							set vector length of {_vHand2} to min(3, (distance between {_destination2} and location of {_hand2}) / 10)
						else if {_destination2} is set:
							set {_vHand2} to {_destination2}.clone().subtract({_hand2}.getLocation()).toVector()
							if {_countAI} = 30 or 70:
								set vector length of {_vHand2} to (distance between {_destination2} and location of {_hand2}) / 10
							else:
								set vector length of {_vHand2} to max(3, (distance between {_destination2} and location of {_hand2}) / 6)
							clear {_destination2}
						set {_locHand} to location of {_hand2}
						teleport {_hand2} to {_locHand}.add({_vHand2})
					else:
						set {_hand2AI} to false
						{_attrMap}.put("defence", ({_attrMap}.get("defence") - 30))
			#head AI
			if {_angry} is true:
				set {_vHead} to {_target}.getLocation().subtract({_klw}.getLocation()).toVector()
				set vector length of {_vHead} to min(2, (distance between {_klw} and {_target}) / 6)
				set {_locHead} to {_klw}.getLocation()
				teleport {_klw} to {_locHead}.add({_vHead})
			else if {_countAI} < 90:
				if {_countAI} = 0:
					{_attrMap}.put("defence", ({_attrMap}.get("defence") + 10))
					set name of {_klw} to "骷髅王"
					{_klw}.setCustomName("骷髅王")
				set {_vHead} to {_target}.getLocation().add(0, 15, 0).subtract({_klw}.getLocation()).toVector()
				set vector length of {_vHead} to min(2, (distance between {_klw} and {_target}) / 10)
				set {_locHead} to {_klw}.getLocation()
				teleport {_klw} to {_locHead}.add({_vHead})
				set {_shoot} to false
				if (health of {_klw}) / (max health of {_klw}) > 0.4:
					mod({_countAI}, 10) = 0
					if health of {_hand1} + health of {_hand2} <= 0:
						set {_shoot} to true
					else if (health of {_klw}) / (max health of {_klw}) < 0.8:
						set {_shoot} to true
				else:
					mod({_countAI}, 4) = 0
					set {_shoot} to true
				if {_shoot}:
					set {_velocity} to ({_target}.getEyeLocation().subtract(0, 1, 0).subtract({_klw}.getLocation())).toVector()
					set {_skull} to {_klw}.getWorld().spawnEntity({_klw}.getEyeLocation(), EntityType.SPLASH_POTION)
					
					set vector length of {_velocity} to 0.75
					{_skull}.setCustomName("诅咒头")
					{_skull}.setVelocity({_velocity})
					{_skull}.setShooter({_klw})
					
					set metadata "attrMap" of {_skull} to {_attrMapSkull}
					disguiseProjectile({_skull})
					handleProjectileKLW({_skull}, {_klw})
					{_skull}.setGravity(false)
			else if {_countAI} = 90:
				{_attrMap}.put("defence", ({_attrMap}.get("defence") - 10))
				play sound "entity.enderdragon.growl" with volume 10 and pitch 1 at location of {_klw}
				set name of {_klw} to "骷髅王&1"
				{_klw}.setCustomName("骷髅王&1")
			else:
				set {_vHead} to {_target}.getLocation().subtract({_klw}.getLocation()).toVector()
				set vector length of {_vHead} to min(2, (distance between {_klw} and {_target}) / 10)
				set {_locHead} to {_klw}.getLocation()
				teleport {_klw} to {_locHead}.add({_vHead})
			add 1 to {_countAI}
		wait 3 ticks
	{_bossbar}.setVisible(false)
	{BOSS}.remove("骷髅王")
	set health of {_hand1} to 0
	set health of {_hand2} to 0
	#drop
	set {_maxHealth} to max health of {_klw}
	{_maxHealth} is not 1
	broadcast "&d&l骷髅王 被击败了."
	set {_targets} to metadata "targets" of {_klw}
	set {_killers} to {_targets}.keySet().iterator()
	set {_drop} to a leather named "&r专家模式福袋" with lore "&7骷髅王"
	while {_killers}.hasNext():
		set {_ply} to {_killers}.next()
		set {_player} to {_ply} parsed as player
		name of {_player} is {_ply}
		set {_tier} to metadata "tier" of {_player}
		if {_targets}.get({_ply}) * 5 > ({_maxHealth}) / ({_targets}.size()):
			if {_tier} = 2:
				set metadata "tier" of {_player} to 3
				set yml value "stats.tier" from file "plugins/PlayerData/%name of {_player}%.yml" to 3
			if {_player} can hold {_drop}:
				send "&a恭喜你击败了BOSS[&r骷髅王&a]!您的战利品已经放在背包里了。" to {_player}
				give {_drop} to {_player}
			else:
				send "&a恭喜你击败了BOSS[&r骷髅王&a]!您的背包空间不足以容纳战利品，请迅速拾起脚下的战利品袋，以免丢失。" to {_player}
				drop {_drop} at {_player}.getEyeLocation() without velocity
		else:
			send "&aBOSS 骷髅王 已经被击败。很遗憾，您的输出不足以获得一份战利品。" to {_player}


function handleProjectileKLW(skull: entity, klw: entity):
	set {_speed} to 0.75
	{_skull}.setGlowing(true)
	loop 300 times:
		set {_target} to target of {_klw}
		set {_v} to velocity of {_skull}
		if {_skull}.getHandle().dead:
			stop trigger
		if loop-number < 17:
			if {_target} is set:
				set {_dV} to {_target}.getEyeLocation().subtract({_skull}.getLocation()).toVector()
				set vector length of {_dV} to 2
				set vector length of {_v} to 5
				{_v}.add({_dV})
		set vector length of {_v} to {_speed}
		set velocity of {_skull} to {_v}
		wait 3 ticks
	{_skull}.remove()